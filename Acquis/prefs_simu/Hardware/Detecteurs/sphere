#
sphere/2voies: ok (HS/ok)
	parms detecteur = {
		masse = 0 	# masse du detecteur (g)
		mode = standard 	# mode de sauvegarde
		demarrage = neant 	# nom du fichier de demarrage de run
		entretien = neant 	# nom du fichier d'entretien periodique
		voisins = () 	# detecteurs a sauver aussi en mode 'voisins'
		associes = () 	# detecteurs a sauver aussi en mode 'individuel'
	}
#
#	---------- Parametrage de la voie signal ----------
#
	parms signal = {
		usage = defaut 	# Utilisation finale de la voie (jetee/defaut/stream/evts/tout)
		sensibilite = 1 	# nV/keV
		Rdetecteur = 1.4013e-45 	# Mohms
	}
	reglages signal = {
		led = off
	}
	evenement signal = {
		duree = 1 	# Duree evenement (ms)
		delai = 0 	# Decalage evenement (ms)
		interv = 2 	# Fenetre de recherche (ms)
		pre-trigger = 20 	# Pre-trigger (%)
		temps-mort = -1 	# Temps mort avant nouvelle recherche (milllisec.) (=post-trigger si <0)
		base.depart = 25 	# Position du debut de ligne de base dans le pre-trigger (%)
		base.arrivee = 75 	# Position de la fin de ligne de base dans le pre-trigger (%)
		temps.depart = 10 	# Debut du temps de montee (%)
		temps.arrivee = 90 	# Fin du temps de montee (%)
		phase1.t0 = 0 	# Debut integrale rapide (ms)
		phase1.dt = 0 	# Duree integrale rapide (ms)
		phase2.t0 = 0 	# Debut integrale longue (ms)
		phase2.dt = 0 	# Duree integrale longue (ms)
		template.dim = 1024 	# Dimension du template (points)
		template.temps.montee = 0.0512 	# temps de montee (ms)
		template.temps.descente1 = 0.14 	# temps de la descente #1 (ms)
		template.temps.descente2 = 0.0512 	# temps de la descente #2 (ms)
		template.facteur.descente2 = 1 	# gain de la descente #2
		moyen.min = 4300 	# Amplitude min pour calcul evt moyen
		moyen.max = 0 	# Amplitude max pour calcul evt moyen
		affichage.min = -8192 	# Signal recu minimum (ADU) [pour l'affichage]
		affichage.max = 8191 	# Signal recu maximum (ADU) [pour l'affichage]
	}
	trmt-au-vol signal = {
		type = neant 	# Traitement au vol (neant/demodulation/filtrage/invalidation)
		parametre = 11 	# Parametre (int) du traitement au vol
		parametre.2 = 0 	# 2eme parametre (int) du traitement au vol
		temps = 0.14 	# Parametre (float) du traitement au vol
		texte = "marge 11" 	# Parametre (char[]) du traitement au vol
		gain = 1 	# Gain logiciel au vol
		execution = au_vol 	# La demodulation peut etre differee (au_vol/sur_tampon)
		deconvolue.calcule = oui 	# Calcule l'evenement deconvolue et la charge associee
		deconvolue.lissage.avant = 3 	# Lissage avant deconvolution
		deconvolue.lissage.apres = 5 	# Lissage apres deconvolution
		deconvolue.descente = 0.13 	# Temps de decroissance du signal (RC preampli)
		deconvolue.integre.seuil = 10 	# Seuil mini au-dessus de la LdB pour integration
		dim.tampon = 8192 	# Dimension du tampon resultat des traitements
		dim.ldb = 50 	# Dimension de l'evaluation de la ligne de base
		periodes.pattern = 0 	# Nb.periodes pour soustraction du pattern
		moyenne.archive = 1 	# Facteur de moyennage avant la sauvegarde des evenements
	}
	trmt-sur-tampon signal = {
		type = lissage 	# Traitement pre-trigger (neant/demodulation/filtrage/invalidation)
		parametre = 3 	# Parametre (int) du traitement pre-trigger
		parametre.2 = 3 	# 2eme parametre (int) du traitement pre-trigger
		temps = 0.14 	# Parametre (float) du traitement pre-trigger
		texte = "sur 3 pts" 	# Parametre (char[]) du traitement pre-trigger
		gain = 1 	# Gain logiciel pre-trigger
		template = neant 	# Filtrage par template (neant/database/analytique)
	}
	trigger signal = {
		type = seuil 	# Type de recherche d'evenement (neant/seuil/front/porte/bruit)
		signe = positif 	# Sens de la variation attendue (negatif/indifferent/positif)
		origine = interne 	# Origine du trigger (interne/deporte/fpga)
		regulation = non 	# Autorisation de reguler automatiquement
		reprise = fixe 	# Tactique de gestion du temps mort apres evenement (fixe/attends_seuil/reporte)
		amplitude.min = 150 	# Amplitude minimum pour impulsions positives (ADU)
		amplitude.max = 0 	# Amplitude maximum pour impulsions negatives (ADU)
		montee = 0.1 	# Temps de montee minimum (microsecs.)
		duree = 0 	# Duree d'evenement minimum (microsecs.)
		#		Coupures avant sauvegarde
		coupures = non 	# Vrai si coupures actives (non/oui/toujours)
		veto = non 	# Vrai si voie en veto
		alpha.amplitude = 40000 	# Seuil pour un temps mort special alpha (ADU)
		alpha.duree = 5000 	# Temps mort special alpha (ms)
		#		Interconnexion entre voies
		connexion.out = non 	# Autorisation de sortie
		connexion.delai = 0 	# Delai de sortie du signal trigger [-1 si pas emis] (millisecs)
		connexion.in = non 	# Autorisation d'entree
		connexion.detec = 0 	# Detecteur branche sur sortie trigger autre voie
		connexion.capteur = 0 	# Capteur (dudit detecteur) branche sur sortie trigger autre voie
	}
	coupures signal = {
		ampl.min = 2000 	# Minimum de l'intervalle
		ampl.max = 6000 	# Maximum de l'intervalle
		ampl.action = passe 	# Action si dans l'intervalle (passe/rejet)
		montee.min = 0 	# Minimum de l'intervalle
		montee.max = 0.01 	# Maximum de l'intervalle
		montee.action = rejet 	# Action si dans l'intervalle (passe/rejet)
		dispers.min = 0.01 	# Minimum de l'intervalle
		dispers.max = 0.1 	# Maximum de l'intervalle
		dispers.action = passe 	# Action si dans l'intervalle (passe/rejet)
	}
	regulation signal = {
		Type = neant 	# Type de regulation (neant/taux/intervalles)
		Plancher.min = 2 	# Plancher pour le seuil min
		Plafond.min = 30000 	# Plafond  pour le seuil min
		Plancher.max = 2 	# Plancher pour le seuil max
		Plafond.max = -30000 	# Plafond  pour le seuil max
		#
		#		Regulation par le taux d'evenements
		#
		Active.1 = oui 	# Echelle de temps #1 en service
		Echelle.1 = 1 	# Echelle de temps #1 (mn)
		Nb.1.min = 60 	# Nombre d'evt minimum a l'echelle #1
		Action.1.min.type = multipl.par 	# Type action si nb1 < min1
		Action.1.min.parm = 2 	# Valeur action si nb1 < min1
		Nb.1.max = 180 	# Nombre d'evt maximum a l'echelle #1
		Action.1.max.type = diviser_par 	# Type action si nb1 > max1
		Action.1.max.parm = 1.5 	# Valeur action si nb1 > max1
		#
		Active.2 = non 	# Echelle de temps #2 en service
		Echelle.2 = 0 	# Echelle de temps #2 (mn)
		Nb.2.min = 0 	# Nombre d'evt minimum a l'echelle #2
		Action.2.min.type = continuer 	# Type action si nb2 < min2
		Action.2.min.parm = 0 	# Valeur action si nb2 < min2
		Nb.2.max = 0 	# Nombre d'evt maximum a l'echelle #2
		Action.2.max.type = continuer 	# Type action si nb2 > max2
		Action.2.max.parm = 0 	# Valeur action si nb2 > max2
		#
		Active.3 = non 	# Echelle de temps #3 en service
		Echelle.3 = 0 	# Echelle de temps #3 (mn)
		Nb.3.min = 0 	# Nombre d'evt minimum a l'echelle #3
		Action.3.min.type = continuer 	# Type action si nb3 < min3
		Action.3.min.parm = 0 	# Valeur action si nb3 < min3
		Nb.3.max = 0 	# Nombre d'evt maximum a l'echelle #3
		Action.3.max.type = continuer 	# Type action si nb3 > max3
		Action.3.max.parm = 0 	# Valeur action si nb3 > max3
		#
		#		Regulation par intervalles
		#
		Interv.nb = 0 	# Nombre d'intervalles
		Interv.duree = 0 	# Longueur (s)
		Interv.ajuste = 0 	# Ajustement seuil (ADU)
		Interv.evt = 0 	# Facteur decision
		Interv.min = 0 	# Delai mini (nb.interv.)
		Interv.incr = 0 	# Increment si bruit (ADU)
	}
	categories signal = {
		liste = (
			{ alpha := ampl.min = 4400, ampl.max = 4999, ampl.action = passe, montee.min = 0.001, montee.max = 0.5, montee.action = passe },
			{ beta := ampl.min = 0, ampl.max = 4399, ampl.action = passe, montee.min = 0.001, montee.max = 0.5, montee.action = passe },
			{ gamma := ampl.min = 5000, ampl.max = 10000, ampl.action = passe, montee.min = 0.004, montee.max = 0.5, montee.action = passe },
			{ muon := ampl.min = 5000, ampl.max = 10000, ampl.action = passe, montee.min = 0.004, montee.max = 0.5, montee.action = passe },
			{ neutron := ampl.min = 5000, ampl.max = 10000, ampl.action = passe, montee.min = 0.004, montee.max = 0.5, montee.action = passe }
		)
	}
#
#	---------- Parametrage de la voie light ----------
#
	parms light = {
		usage = defaut 	# Utilisation finale de la voie (jetee/defaut/stream/evts/tout)
		sensibilite = 1 	# nV/keV
		Rdetecteur = 1.4013e-45 	# Mohms
	}
	reglages light = {
	}
	evenement light = {
		duree = 1 	# Duree evenement (ms)
		delai = 0 	# Decalage evenement (ms)
		interv = 2 	# Fenetre de recherche (ms)
		pre-trigger = 20 	# Pre-trigger (%)
		temps-mort = -1 	# Temps mort avant nouvelle recherche (milllisec.) (=post-trigger si <0)
		base.depart = 25 	# Position du debut de ligne de base dans le pre-trigger (%)
		base.arrivee = 75 	# Position de la fin de ligne de base dans le pre-trigger (%)
		temps.depart = 10 	# Debut du temps de montee (%)
		temps.arrivee = 90 	# Fin du temps de montee (%)
		phase1.t0 = 0 	# Debut integrale rapide (ms)
		phase1.dt = 0 	# Duree integrale rapide (ms)
		phase2.t0 = 0 	# Debut integrale longue (ms)
		phase2.dt = 0 	# Duree integrale longue (ms)
		template.dim = 1024 	# Dimension du template (points)
		template.temps.montee = 0.05 	# temps de montee (ms)
		template.temps.descente1 = 0.14 	# temps de la descente #1 (ms)
		template.temps.descente2 = 0.02 	# temps de la descente #2 (ms)
		template.facteur.descente2 = 1 	# gain de la descente #2
		moyen.min = 4300 	# Amplitude min pour calcul evt moyen
		moyen.max = 0 	# Amplitude max pour calcul evt moyen
		affichage.min = -8192 	# Signal recu minimum (ADU) [pour l'affichage]
		affichage.max = 8191 	# Signal recu maximum (ADU) [pour l'affichage]
	}
	trmt-au-vol light = {
		type = neant 	# Traitement au vol (neant/demodulation/filtrage/invalidation)
		parametre = 1 	# Parametre (int) du traitement au vol
		parametre.2 = 0 	# 2eme parametre (int) du traitement au vol
		temps = 0.14 	# Parametre (float) du traitement au vol
		texte = "marge 1" 	# Parametre (char[]) du traitement au vol
		gain = 1 	# Gain logiciel au vol
		execution = au_vol 	# La demodulation peut etre differee (au_vol/sur_tampon)
		deconvolue.calcule = oui 	# Calcule l'evenement deconvolue et la charge associee
		deconvolue.lissage.avant = 3 	# Lissage avant deconvolution
		deconvolue.lissage.apres = 5 	# Lissage apres deconvolution
		deconvolue.descente = 0.13 	# Temps de decroissance du signal (RC preampli)
		deconvolue.integre.seuil = 10 	# Seuil mini au-dessus de la LdB pour integration
		dim.tampon = 8192 	# Dimension du tampon resultat des traitements
		dim.ldb = 50 	# Dimension de l'evaluation de la ligne de base
		periodes.pattern = 0 	# Nb.periodes pour soustraction du pattern
		moyenne.archive = 1 	# Facteur de moyennage avant la sauvegarde des evenements
	}
	trmt-sur-tampon light = {
		type = filtrage 	# Traitement pre-trigger (neant/demodulation/filtrage/invalidation)
		parametre = 0 	# Parametre (int) du traitement pre-trigger
		parametre.2 = 0 	# 2eme parametre (int) du traitement pre-trigger
		temps = 0.14 	# Parametre (float) du traitement pre-trigger
		texte = ButH2/100Hz 	# Parametre (char[]) du traitement pre-trigger
		gain = 1 	# Gain logiciel pre-trigger
		template = neant 	# Filtrage par template (neant/database/analytique)
	}
	trigger light = {
		type = neant 	# Type de recherche d'evenement (neant/seuil/front/porte/bruit)
		signe = positif 	# Sens de la variation attendue (negatif/indifferent/positif)
		origine = interne 	# Origine du trigger (interne/deporte/fpga)
		regulation = non 	# Autorisation de reguler automatiquement
		reprise = fixe 	# Tactique de gestion du temps mort apres evenement (fixe/attends_seuil/reporte)
		amplitude.min = 100 	# Amplitude minimum pour impulsions positives (ADU)
		amplitude.max = -50 	# Amplitude maximum pour impulsions negatives (ADU)
		montee = 10.24 	# Temps de montee minimum (microsecs.)
		duree = 0 	# Duree d'evenement minimum (microsecs.)
		#		Coupures avant sauvegarde
		coupures = non 	# Vrai si coupures actives (non/oui/toujours)
		veto = non 	# Vrai si voie en veto
		alpha.amplitude = 40000 	# Seuil pour un temps mort special alpha (ADU)
		alpha.duree = 5000 	# Temps mort special alpha (ms)
		#		Interconnexion entre voies
		connexion.out = non 	# Autorisation de sortie
		connexion.delai = 0 	# Delai de sortie du signal trigger [-1 si pas emis] (millisecs)
		connexion.in = non 	# Autorisation d'entree
		connexion.detec = 0 	# Detecteur branche sur sortie trigger autre voie
		connexion.capteur = 0 	# Capteur (dudit detecteur) branche sur sortie trigger autre voie
	}
	coupures light = {
		ampl.min = 0 	# Minimum de l'intervalle
		ampl.max = 0 	# Maximum de l'intervalle
		ampl.action = passe 	# Action si dans l'intervalle (passe/rejet)
		montee.min = 0 	# Minimum de l'intervalle
		montee.max = 0 	# Maximum de l'intervalle
		montee.action = passe 	# Action si dans l'intervalle (passe/rejet)
		dispers.min = 0 	# Minimum de l'intervalle
		dispers.max = 0 	# Maximum de l'intervalle
		dispers.action = passe 	# Action si dans l'intervalle (passe/rejet)
	}
	regulation light = {
		Type = neant 	# Type de regulation (neant/taux/intervalles)
		Plancher.min = 0 	# Plancher pour le seuil min
		Plafond.min = 0 	# Plafond  pour le seuil min
		Plancher.max = 0 	# Plancher pour le seuil max
		Plafond.max = 0 	# Plafond  pour le seuil max
		#
		#		Regulation par le taux d'evenements
		#
		Active.1 = non 	# Echelle de temps #1 en service
		Echelle.1 = 0 	# Echelle de temps #1 (mn)
		Nb.1.min = 0 	# Nombre d'evt minimum a l'echelle #1
		Action.1.min.type = continuer 	# Type action si nb1 < min1
		Action.1.min.parm = 0 	# Valeur action si nb1 < min1
		Nb.1.max = 0 	# Nombre d'evt maximum a l'echelle #1
		Action.1.max.type = continuer 	# Type action si nb1 > max1
		Action.1.max.parm = 0 	# Valeur action si nb1 > max1
		#
		Active.2 = non 	# Echelle de temps #2 en service
		Echelle.2 = 0 	# Echelle de temps #2 (mn)
		Nb.2.min = 0 	# Nombre d'evt minimum a l'echelle #2
		Action.2.min.type = continuer 	# Type action si nb2 < min2
		Action.2.min.parm = 0 	# Valeur action si nb2 < min2
		Nb.2.max = 0 	# Nombre d'evt maximum a l'echelle #2
		Action.2.max.type = continuer 	# Type action si nb2 > max2
		Action.2.max.parm = 0 	# Valeur action si nb2 > max2
		#
		Active.3 = non 	# Echelle de temps #3 en service
		Echelle.3 = 0 	# Echelle de temps #3 (mn)
		Nb.3.min = 0 	# Nombre d'evt minimum a l'echelle #3
		Action.3.min.type = continuer 	# Type action si nb3 < min3
		Action.3.min.parm = 0 	# Valeur action si nb3 < min3
		Nb.3.max = 0 	# Nombre d'evt maximum a l'echelle #3
		Action.3.max.type = continuer 	# Type action si nb3 > max3
		Action.3.max.parm = 0 	# Valeur action si nb3 > max3
		#
		#		Regulation par intervalles
		#
		Interv.nb = 0 	# Nombre d'intervalles
		Interv.duree = 0 	# Longueur (s)
		Interv.ajuste = 0 	# Ajustement seuil (ADU)
		Interv.evt = 0 	# Facteur decision
		Interv.min = 0 	# Delai mini (nb.interv.)
		Interv.incr = 0 	# Increment si bruit (ADU)
	}
	categories light = {
		liste = { neutron := ampl.min = 0, ampl.max = 2000, ampl.action = passe, montee.min = 0, montee.max = 1, montee.action = passe }
	}
	registres = {
		x00171F
	}
